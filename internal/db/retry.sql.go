// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: retry.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createJobWithRetries = `-- name: CreateJobWithRetries :one
INSERT INTO jobs (
    type, binary_url, binary_sha256, arguments, env_variables, 
    priority, status, max_retries
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

type CreateJobWithRetriesParams struct {
	Type         string   `json:"type"`
	BinaryUrl    string   `json:"binary_url"`
	BinarySha256 string   `json:"binary_sha256"`
	Arguments    []string `json:"arguments"`
	EnvVariables []byte   `json:"env_variables"`
	Priority     string   `json:"priority"`
	Status       string   `json:"status"`
	MaxRetries   int32    `json:"max_retries"`
}

func (q *Queries) CreateJobWithRetries(ctx context.Context, arg CreateJobWithRetriesParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJobWithRetries,
		arg.Type,
		arg.BinaryUrl,
		arg.BinarySha256,
		arg.Arguments,
		arg.EnvVariables,
		arg.Priority,
		arg.Status,
		arg.MaxRetries,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const getRetriableJobs = `-- name: GetRetriableJobs :many
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after FROM jobs
WHERE status = 'failed' 
  AND retry_count < max_retries
  AND (retry_after IS NULL OR retry_after < NOW())
ORDER BY priority, created_at
LIMIT 10
`

func (q *Queries) GetRetriableJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.Query(ctx, getRetriableJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.BinaryUrl,
			&i.BinarySha256,
			&i.Arguments,
			&i.EnvVariables,
			&i.Priority,
			&i.Status,
			&i.ExecutorID,
			&i.Stdout,
			&i.Stderr,
			&i.ExitCode,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastHeartbeat,
			&i.MaxRetries,
			&i.RetryCount,
			&i.RetryAfter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementJobRetry = `-- name: IncrementJobRetry :exec
UPDATE jobs 
SET retry_count = retry_count + 1,
    status = 'pending',
    retry_after = NOW() + INTERVAL '1 minute' * POWER(2, retry_count), -- Exponential backoff
    error_message = NULL,
    stdout = NULL,
    stderr = NULL,
    exit_code = NULL,
    started_at = NULL,
    completed_at = NULL,
    executor_id = NULL,
    last_heartbeat = NULL
WHERE id = $1
  AND status = 'failed'
  AND retry_count < max_retries
`

func (q *Queries) IncrementJobRetry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementJobRetry, id)
	return err
}
