// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: stats.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countJobsByStatus = `-- name: CountJobsByStatus :many
SELECT status, COUNT(*) as count
FROM jobs
GROUP BY status
`

type CountJobsByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountJobsByStatus(ctx context.Context) ([]CountJobsByStatusRow, error) {
	rows, err := q.db.Query(ctx, countJobsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountJobsByStatusRow{}
	for rows.Next() {
		var i CountJobsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countPendingJobsByPriority = `-- name: CountPendingJobsByPriority :many
SELECT priority, COUNT(*) as count
FROM jobs
WHERE status = 'pending'
GROUP BY priority
`

type CountPendingJobsByPriorityRow struct {
	Priority string `json:"priority"`
	Count    int64  `json:"count"`
}

func (q *Queries) CountPendingJobsByPriority(ctx context.Context) ([]CountPendingJobsByPriorityRow, error) {
	rows, err := q.db.Query(ctx, countPendingJobsByPriority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountPendingJobsByPriorityRow{}
	for rows.Next() {
		var i CountPendingJobsByPriorityRow
		if err := rows.Scan(&i.Priority, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveExecutors = `-- name: GetActiveExecutors :many
SELECT DISTINCT 
    j.executor_id,
    j.id as job_id,
    j.type as job_type,
    j.last_heartbeat,
    (SELECT COUNT(*) FROM jobs WHERE executor_id = j.executor_id AND status = 'completed') as jobs_completed
FROM jobs j
WHERE j.status = 'running' 
   AND j.last_heartbeat > NOW() - INTERVAL '30 seconds'
ORDER BY j.last_heartbeat DESC
`

type GetActiveExecutorsRow struct {
	ExecutorID    pgtype.Text        `json:"executor_id"`
	JobID         uuid.UUID          `json:"job_id"`
	JobType       string             `json:"job_type"`
	LastHeartbeat pgtype.Timestamptz `json:"last_heartbeat"`
	JobsCompleted int64              `json:"jobs_completed"`
}

func (q *Queries) GetActiveExecutors(ctx context.Context) ([]GetActiveExecutorsRow, error) {
	rows, err := q.db.Query(ctx, getActiveExecutors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveExecutorsRow{}
	for rows.Next() {
		var i GetActiveExecutorsRow
		if err := rows.Scan(
			&i.ExecutorID,
			&i.JobID,
			&i.JobType,
			&i.LastHeartbeat,
			&i.JobsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobRetryCount = `-- name: GetJobRetryCount :one
SELECT COUNT(*) as retry_count
FROM job_attempts
WHERE job_id = $1
`

func (q *Queries) GetJobRetryCount(ctx context.Context, jobID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getJobRetryCount, jobID)
	var retry_count int64
	err := row.Scan(&retry_count)
	return retry_count, err
}
