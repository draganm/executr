// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: jobs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelJob = `-- name: CancelJob :exec
UPDATE jobs SET
    status = 'cancelled',
    completed_at = NOW(),
    error_message = 'Job cancelled by user'
WHERE id = $1 AND status = 'pending'
`

func (q *Queries) CancelJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, cancelJob, id)
	return err
}

const claimNextJob = `-- name: ClaimNextJob :one
UPDATE jobs SET
    status = 'running',
    executor_id = $1,
    started_at = NOW(),
    last_heartbeat = NOW()
WHERE id = (
    SELECT id FROM jobs
    WHERE status = 'pending'
    ORDER BY 
        CASE priority 
            WHEN 'foreground' THEN 1
            WHEN 'background' THEN 2
            WHEN 'best_effort' THEN 3
        END,
        created_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT 1
)
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat
`

func (q *Queries) ClaimNextJob(ctx context.Context, executorID pgtype.Text) (Job, error) {
	row := q.db.QueryRow(ctx, claimNextJob, executorID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
	)
	return i, err
}

const cleanupOldJobs = `-- name: CleanupOldJobs :exec
DELETE FROM jobs
WHERE status IN ('completed', 'failed', 'cancelled')
  AND completed_at < NOW() - INTERVAL '1 second' * CAST($1 AS INTEGER)
`

func (q *Queries) CleanupOldJobs(ctx context.Context, dollar_1 int32) error {
	_, err := q.db.Exec(ctx, cleanupOldJobs, dollar_1)
	return err
}

const completeJob = `-- name: CompleteJob :exec
UPDATE jobs SET
    status = 'completed',
    stdout = $2,
    stderr = $3,
    exit_code = $4,
    completed_at = NOW()
WHERE id = $1 AND executor_id = $5 AND status = 'running'
`

type CompleteJobParams struct {
	ID         uuid.UUID   `json:"id"`
	Stdout     pgtype.Text `json:"stdout"`
	Stderr     pgtype.Text `json:"stderr"`
	ExitCode   pgtype.Int4 `json:"exit_code"`
	ExecutorID pgtype.Text `json:"executor_id"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) error {
	_, err := q.db.Exec(ctx, completeJob,
		arg.ID,
		arg.Stdout,
		arg.Stderr,
		arg.ExitCode,
		arg.ExecutorID,
	)
	return err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    type, binary_url, binary_sha256, arguments, env_variables,
    priority, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat
`

type CreateJobParams struct {
	Type         string   `json:"type"`
	BinaryUrl    string   `json:"binary_url"`
	BinarySha256 string   `json:"binary_sha256"`
	Arguments    []string `json:"arguments"`
	EnvVariables []byte   `json:"env_variables"`
	Priority     string   `json:"priority"`
	Status       string   `json:"status"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Type,
		arg.BinaryUrl,
		arg.BinarySha256,
		arg.Arguments,
		arg.EnvVariables,
		arg.Priority,
		arg.Status,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const failJob = `-- name: FailJob :exec
UPDATE jobs SET
    status = 'failed',
    error_message = $2,
    stdout = $3,
    stderr = $4,
    exit_code = $5,
    completed_at = NOW()
WHERE id = $1 AND executor_id = $6 AND status = 'running'
`

type FailJobParams struct {
	ID           uuid.UUID   `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
	Stdout       pgtype.Text `json:"stdout"`
	Stderr       pgtype.Text `json:"stderr"`
	ExitCode     pgtype.Int4 `json:"exit_code"`
	ExecutorID   pgtype.Text `json:"executor_id"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.Exec(ctx, failJob,
		arg.ID,
		arg.ErrorMessage,
		arg.Stdout,
		arg.Stderr,
		arg.ExitCode,
		arg.ExecutorID,
	)
	return err
}

const findStaleJobs = `-- name: FindStaleJobs :many
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat FROM jobs
WHERE status = 'running'
  AND last_heartbeat < NOW() - INTERVAL '1 second' * CAST($1 AS INTEGER)
`

func (q *Queries) FindStaleJobs(ctx context.Context, dollar_1 int32) ([]Job, error) {
	rows, err := q.db.Query(ctx, findStaleJobs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.BinaryUrl,
			&i.BinarySha256,
			&i.Arguments,
			&i.EnvVariables,
			&i.Priority,
			&i.Status,
			&i.ExecutorID,
			&i.Stdout,
			&i.Stderr,
			&i.ExitCode,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastHeartbeat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat FROM jobs WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
	)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat FROM jobs
WHERE ($1::text IS NULL OR status = $1)
  AND ($2::text IS NULL OR type = $2)
  AND ($3::text IS NULL OR priority = $3)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListJobsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.BinaryUrl,
			&i.BinarySha256,
			&i.Arguments,
			&i.EnvVariables,
			&i.Priority,
			&i.Status,
			&i.ExecutorID,
			&i.Stdout,
			&i.Stderr,
			&i.ExitCode,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastHeartbeat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStaleJob = `-- name: ResetStaleJob :exec
UPDATE jobs SET
    status = 'pending',
    executor_id = NULL,
    started_at = NULL,
    last_heartbeat = NULL
WHERE id = $1 AND status = 'running'
`

func (q *Queries) ResetStaleJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetStaleJob, id)
	return err
}

const updateJob = `-- name: UpdateJob :exec
UPDATE jobs SET
    status = COALESCE($2, status),
    executor_id = COALESCE($3, executor_id),
    stdout = COALESCE($4, stdout),
    stderr = COALESCE($5, stderr),
    exit_code = COALESCE($6, exit_code),
    error_message = COALESCE($7, error_message),
    started_at = COALESCE($8, started_at),
    completed_at = COALESCE($9, completed_at),
    last_heartbeat = COALESCE($10, last_heartbeat)
WHERE id = $1
`

type UpdateJobParams struct {
	ID            uuid.UUID          `json:"id"`
	Status        string             `json:"status"`
	ExecutorID    pgtype.Text        `json:"executor_id"`
	Stdout        pgtype.Text        `json:"stdout"`
	Stderr        pgtype.Text        `json:"stderr"`
	ExitCode      pgtype.Int4        `json:"exit_code"`
	ErrorMessage  pgtype.Text        `json:"error_message"`
	StartedAt     pgtype.Timestamptz `json:"started_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	LastHeartbeat pgtype.Timestamptz `json:"last_heartbeat"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) error {
	_, err := q.db.Exec(ctx, updateJob,
		arg.ID,
		arg.Status,
		arg.ExecutorID,
		arg.Stdout,
		arg.Stderr,
		arg.ExitCode,
		arg.ErrorMessage,
		arg.StartedAt,
		arg.CompletedAt,
		arg.LastHeartbeat,
	)
	return err
}

const updateJobHeartbeat = `-- name: UpdateJobHeartbeat :exec
UPDATE jobs SET
    last_heartbeat = NOW()
WHERE id = $1 AND executor_id = $2 AND status = 'running'
`

type UpdateJobHeartbeatParams struct {
	ID         uuid.UUID   `json:"id"`
	ExecutorID pgtype.Text `json:"executor_id"`
}

func (q *Queries) UpdateJobHeartbeat(ctx context.Context, arg UpdateJobHeartbeatParams) error {
	_, err := q.db.Exec(ctx, updateJobHeartbeat, arg.ID, arg.ExecutorID)
	return err
}
