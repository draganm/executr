// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: jobs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cancelJob = `-- name: CancelJob :one
UPDATE jobs
SET status = 'cancelled',
    completed_at = NOW()
WHERE id = $1 AND status = 'pending'
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

func (q *Queries) CancelJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, cancelJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const claimNextJob = `-- name: ClaimNextJob :one
UPDATE jobs
SET status = 'running',
    executor_id = $1,
    started_at = NOW(),
    last_heartbeat = NOW()
WHERE id = (
    SELECT id FROM jobs
    WHERE status = 'pending'
    ORDER BY 
        CASE priority
            WHEN 'foreground' THEN 1
            WHEN 'background' THEN 2
            WHEN 'best_effort' THEN 3
        END,
        created_at
    FOR UPDATE SKIP LOCKED
    LIMIT 1
)
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

func (q *Queries) ClaimNextJob(ctx context.Context, executorID pgtype.Text) (Job, error) {
	row := q.db.QueryRow(ctx, claimNextJob, executorID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const cleanupOldJobs = `-- name: CleanupOldJobs :exec
DELETE FROM jobs
WHERE status IN ('completed', 'failed', 'cancelled')
  AND completed_at < NOW() - $1::interval
`

func (q *Queries) CleanupOldJobs(ctx context.Context, dollar_1 pgtype.Interval) error {
	_, err := q.db.Exec(ctx, cleanupOldJobs, dollar_1)
	return err
}

const completeJob = `-- name: CompleteJob :one
UPDATE jobs
SET status = 'completed',
    stdout = $2,
    stderr = $3,
    exit_code = $4,
    completed_at = NOW()
WHERE id = $1 AND status = 'running'
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

type CompleteJobParams struct {
	ID       uuid.UUID   `json:"id"`
	Stdout   pgtype.Text `json:"stdout"`
	Stderr   pgtype.Text `json:"stderr"`
	ExitCode pgtype.Int4 `json:"exit_code"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, completeJob,
		arg.ID,
		arg.Stdout,
		arg.Stderr,
		arg.ExitCode,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    type, binary_url, binary_sha256, arguments, env_variables, priority
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

type CreateJobParams struct {
	Type         string   `json:"type"`
	BinaryUrl    string   `json:"binary_url"`
	BinarySha256 string   `json:"binary_sha256"`
	Arguments    []string `json:"arguments"`
	EnvVariables []byte   `json:"env_variables"`
	Priority     string   `json:"priority"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Type,
		arg.BinaryUrl,
		arg.BinarySha256,
		arg.Arguments,
		arg.EnvVariables,
		arg.Priority,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const failJob = `-- name: FailJob :one
UPDATE jobs
SET status = 'failed',
    stdout = $2,
    stderr = $3,
    exit_code = $4,
    error_message = $5,
    completed_at = NOW()
WHERE id = $1 AND status = 'running'
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

type FailJobParams struct {
	ID           uuid.UUID   `json:"id"`
	Stdout       pgtype.Text `json:"stdout"`
	Stderr       pgtype.Text `json:"stderr"`
	ExitCode     pgtype.Int4 `json:"exit_code"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, failJob,
		arg.ID,
		arg.Stdout,
		arg.Stderr,
		arg.ExitCode,
		arg.ErrorMessage,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const findStaleJobs = `-- name: FindStaleJobs :many
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after FROM jobs
WHERE status = 'running'
  AND last_heartbeat < NOW() - INTERVAL '15 seconds'
`

func (q *Queries) FindStaleJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.Query(ctx, findStaleJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.BinaryUrl,
			&i.BinarySha256,
			&i.Arguments,
			&i.EnvVariables,
			&i.Priority,
			&i.Status,
			&i.ExecutorID,
			&i.Stdout,
			&i.Stderr,
			&i.ExitCode,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastHeartbeat,
			&i.MaxRetries,
			&i.RetryCount,
			&i.RetryAfter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after FROM jobs
WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}

const listJobs = `-- name: ListJobs :many
SELECT id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after FROM jobs
WHERE ($1::text IS NULL OR status = $1)
  AND ($2::text IS NULL OR type = $2)
  AND ($3::text IS NULL OR priority = $3)
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListJobsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.BinaryUrl,
			&i.BinarySha256,
			&i.Arguments,
			&i.EnvVariables,
			&i.Priority,
			&i.Status,
			&i.ExecutorID,
			&i.Stdout,
			&i.Stderr,
			&i.ExitCode,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastHeartbeat,
			&i.MaxRetries,
			&i.RetryCount,
			&i.RetryAfter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStaleJob = `-- name: ResetStaleJob :exec
UPDATE jobs
SET status = 'pending',
    executor_id = NULL,
    started_at = NULL,
    last_heartbeat = NULL
WHERE id = $1 AND status = 'running'
`

func (q *Queries) ResetStaleJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetStaleJob, id)
	return err
}

const updateHeartbeat = `-- name: UpdateHeartbeat :exec
UPDATE jobs
SET last_heartbeat = NOW()
WHERE id = $1 AND executor_id = $2 AND status = 'running'
`

type UpdateHeartbeatParams struct {
	ID         uuid.UUID   `json:"id"`
	ExecutorID pgtype.Text `json:"executor_id"`
}

func (q *Queries) UpdateHeartbeat(ctx context.Context, arg UpdateHeartbeatParams) error {
	_, err := q.db.Exec(ctx, updateHeartbeat, arg.ID, arg.ExecutorID)
	return err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE jobs
SET status = $2,
    started_at = CASE WHEN $2 = 'running' THEN COALESCE(started_at, NOW()) ELSE started_at END,
    completed_at = CASE WHEN $2 IN ('completed', 'failed', 'cancelled') THEN NOW() ELSE completed_at END
WHERE id = $1
RETURNING id, type, binary_url, binary_sha256, arguments, env_variables, priority, status, executor_id, stdout, stderr, exit_code, error_message, created_at, started_at, completed_at, last_heartbeat, max_retries, retry_count, retry_after
`

type UpdateJobStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.ID, arg.Status)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.BinaryUrl,
		&i.BinarySha256,
		&i.Arguments,
		&i.EnvVariables,
		&i.Priority,
		&i.Status,
		&i.ExecutorID,
		&i.Stdout,
		&i.Stderr,
		&i.ExitCode,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastHeartbeat,
		&i.MaxRetries,
		&i.RetryCount,
		&i.RetryAfter,
	)
	return i, err
}
